<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta
 content="HTML Tidy for Mac OS X (vers 1st December 2002), see www.w3.org"
 name="generator">
  <meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
  <meta name="Matmap Documentation" content="none">
  <link href="site.css" type="text/css" rel="stylesheet">
  <title>Matmap Documentation</title>
  <style type="text/css"> </style>
</head>
<body>
<div id="page_category">Matmap Documentation</div>
<script type="text/javascript" src="site.js"></script>
<script type="text/javascript">preContent();</script><big><big><span
 style="font-weight: bold;"><br>
</span></big></big><big><a href="index.html"><big>[documentation home]</big></a><br>
<br>
</big><big><big><big>Software Reference</big></big><br>
</big><br>
This documention page has been generated automatically at 05-May-2004<br>
<big style="font-weight: bold;"><big><br>
</big></big><big><big>Topics</big></big><big style="font-weight: bold;"><big><br>
</big></big><font size="2" color="#FFFFFF"><a href="act.html">ACT - Contents of the act directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="bem.html">BEM - Contents of the bem directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="bin.html">BIN - Contents of the bin directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="doc.html">DOC - Contents of the doc directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="fids.html">FIDS - Contents of the fids directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="geom.html">GEOM - Contents of the geom directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="gui.html">GUI - Contents of the gui directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="io.html">IO - Contents of the io directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="mex.html">MEX - Contents of the mex directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="misc.html">MISC - Contents of the misc directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="msg.html">MSG - Contents of the msg directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="script.html">SCRIPT - Contents of the script directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="sig.html">SIG - Contents of the sig directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="triangulationtools.html">TRIANGULATIONTOOLS - Contents of the triangulationtools directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="ts.html">TS - Contents of the ts directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="util.html">UTIL - Contents of the util directory</a></font><br>


<font size="2" color="#FFFFFF"><a href="win.html">WIN - Contents of the win directory</a></font><br>


<big style="font-weight: bold;"><big><br>
<br>
</big></big>
<big><big> Documentation for the TRIANGULATIONTOOLS directory </big></big><br>Contents: automaticly generated doucmentation <br>Filename: triangulationtools.doc <br>Creation date: 05-May-2004 <br><br><br> <big><big> Contents </big></big> <br><a href="#ref1">CheckTriangulation</a><br><a href="#ref2">TriangulateNC</a><br><a href="#ref3">triAlignFacPts</a><br><a href="#ref4">triClockWise</a><br><a href="#ref5">triFindNeighbor</a><br><a href="#ref6">triFitCircle</a><br><a href="#ref7">triLaplacianInterpolation</a><br><a href="#ref8">triMergeNodes</a><br><a href="#ref9">triReOrderPts</a><br><a href="#ref10">triRotMatrix4</a><br><a href="#ref11">triSliceSurface</a><br><a href="#ref12">triSortSlices</a><br><a href="#ref13">triSplitInPlanes</a><br><a href="#ref14">triSurfaceLaplacian</a><br><a href="#ref15">triTriangulate</a><br><a href="#ref16">triVector3</a><br><a href="#ref17">triVector4</a><br><br><br><a name="ref1"></a><br><big><big>CheckTriangulation</big></big><br><br><pre>  This function checks if the triangulation went OK
</pre><a name="ref2"></a><br><big><big>TriangulateNC</big></big><br><br><pre>  function Boundary = SlicesToPos(Slices)
&nbsp; This function converts data obtained from slices
&nbsp; in a three dimensional image build out of triangles
&nbsp; the routine uses a simple algorithm 
</pre><a name="ref3"></a><br><big><big>triAlignFacPts</big></big><br><br><pre>  function [Pts,Fac] = triAlignFacPts(OldPts,Pts,Fac)
&nbsp;
&nbsp; This function rearranges an Pts and Fac matrix so the order in the
&nbsp; matrices matches that of the order given in the OldPts matrix
&nbsp; the function assumes oldPts and Pts to derive from the same dataset of points
&nbsp; although small deviations may occur between the nodes. The function uses a
&nbsp; basic distance criterium to match points. So no translation or rotation is allowed
&nbsp; at this point. (Perhaps some future version will do). 
&nbsp; furthermore the functions does everything so you can still use the old mapping files
&nbsp; 
&nbsp; see ioWriteFac ioWritePts ioReadPts ioReadfac
</pre><a name="ref4"></a><br><big><big>triClockWise</big></big><br><br><pre>  FUNCITON fac = triClockWise(fac,pts)
&nbsp;
&nbsp; DESCRIPTION
&nbsp; Correct a triangulation and make all triangles CW
&nbsp; 
&nbsp; INPUT
&nbsp; fac     Triangulation data
&nbsp; pts     Points file
&nbsp; 
&nbsp; OUTPUT
&nbsp; fac     The new triangulation file
&nbsp;
</pre><a name="ref5"></a><br><big><big>triFindNeighbor</big></big><br><br><pre></pre><a name="ref6"></a><br><big><big>triFitCircle</big></big><br><br><pre>  FUNCTION [r,center] = triFitCircle(pts)
&nbsp;
&nbsp; DESCRIPTION
&nbsp; This function fits a circle through the points and tries to
&nbsp; minimise the distance between the points and the circle in a
&nbsp; least squares sence
&nbsp;
&nbsp; INPUT
&nbsp; pts     2D points array
&nbsp; 
&nbsp; OUTPUT
&nbsp; r       radius of circle
&nbsp; center  the center of the circle
&nbsp;
&nbsp; SEE ALSO -
</pre><a name="ref7"></a><br><big><big>triLaplacianInterpolation</big></big><br><br><pre>  FUNCTION Lint = triLaplacianInterpolation(surface,badleads,[numleads])
&nbsp;
&nbsp; DESCRIPTION
&nbsp; This function computes a transfer matrix from the full potential vector
&nbsp; with the potentials of the badleads to a full vector in which the
&nbsp; bad leads have been interpolated using the known data. THhe function 
&nbsp; uses the laplacian interpolation scheme (Ootendorp 1989, J Computational 
&nbsp; Physics 80,331-343).
&nbsp;
&nbsp;  Utot_int = Lint*Utot_old
&nbsp;
&nbsp; INPUT
&nbsp; surface     A surface description with fields .pts/.channels and .fac
&nbsp; badleads    The leads you want to interpolate
&nbsp; numleads    Number of leads, As the total number of leads is not
&nbsp;             available from the channels file this separate entry
&nbsp;             will define the dimensions of Lint. If you do not use
&nbsp;             .chaannel files the function won't need this input
&nbsp;
&nbsp; OUTPUT
&nbsp; Lint        The interpolation matrix
&nbsp;
&nbsp; SEE ALSO triSurfaceLaplacian
</pre><a name="ref8"></a><br><big><big>triMergeNodes</big></big><br><br><pre>  FUNCTION [Pts,Fac,Channels] = triMergeNodes(Pts,Fac,Node1,Node2,Channels)
&nbsp;
&nbsp; DESCRIPTION
&nbsp; Merge two points in an existing mesh.
&nbsp;
&nbsp; INPUT
&nbsp;    Pts,Fac     define the original mesh
&nbsp;    Node1,Node2 are the nodes to be merged, in the process Node2 will be removed
&nbsp;
&nbsp; OUTPUT
&nbsp;    Pts,Fac     the new mesh
</pre><a name="ref9"></a><br><big><big>triReOrderPts</big></big><br><br><pre>  function [Order,IOrder] = triReOrderPts(PtsOld,PtsNew)
&nbsp;
&nbsp; This function matches by looking at the minimum distance
&nbsp; which column of the old pts-file matches the new one
&nbsp;
&nbsp; Order the way the PtsNew file is order assuming the OldOne as standard
&nbsp;
</pre><a name="ref10"></a><br><big><big>triRotMatrix4</big></big><br><br><pre>  function RM = triRotMatrix4(Origin,Normal)
&nbsp;
&nbsp; This function creates an opengl like matrix rotating
&nbsp; around the origin and pointing the normal along the z-axis
&nbsp;
&nbsp; RM is the rotation matrix (4x4)
</pre><a name="ref11"></a><br><big><big>triSliceSurface</big></big><br><br><pre>  FUNCTION surface = triSliceSurface(surface,origin,normal,options)
&nbsp;
&nbsp; DESCRIPTION
&nbsp; This function slices a model in two and only keeps one part and fills up
&nbsp; the sliced part
&nbsp;
&nbsp; INPUT
&nbsp; surface     surface to be sliced
&nbsp; origin      a point on the cutting plane
&nbsp; normal      a normal to the cutting plane pointing outward
&nbsp; 
&nbsp; OPTIONS
&nbsp; 'fill',distance   
&nbsp;             fill the cutting plane and use distance as a measure for a regular grid
&nbsp;
&nbsp; OUTPUT
&nbsp; surface     new surface
&nbsp;
&nbsp; SEE ALSO -
</pre><a name="ref12"></a><br><big><big>triSortSlices</big></big><br><br><pre>  function Slices = triSortSlices(Pos,Slices,Normal,[Origin])
&nbsp;
&nbsp; This function sorts the points collected in one slice to rotate in an orderly fashion
&nbsp; around a central point.
&nbsp;
&nbsp; INPUT
&nbsp;  Pos    - Matrix containing the node positions;
&nbsp;  Slices - the cell array that contains the indices of the nodes that form one contour
&nbsp;  Normal - Normal to the plane in which the the nodes need to be ordered
&nbsp;  Origin - Origin from which the rotation and radius of the points of the curve should be calculated
&nbsp;           default - The gravitational center of the cloud of points contained in one slice
&nbsp;
&nbsp; OUTPUT
&nbsp;  Slices - A cell array in which the indices are nicely ordered
&nbsp;
&nbsp; The algorithm is pretty easy. It just determines the angle and the radius of the points and
&nbsp; uses the angle to sort the points
</pre><a name="ref13"></a><br><big><big>triSplitInPlanes</big></big><br><br><pre>  function CPos = triSplitInPlanes(Pos, Origin, Normal, Step)
&nbsp;
&nbsp; this function splits the data into splices and just looks in which 
&nbsp; slice the nodes should be.
&nbsp;
&nbsp; using a least squares fit the distance to planes is determined, and the point
&nbsp; is grouped in the plane to which it is closest
&nbsp;
&nbsp; INPUT
&nbsp; Pos - position file (pts file)
&nbsp; Origin - Where to start (vector)
&nbsp; Normal - Where are the vectors normal to (vector)
&nbsp; Step   - Vector describing where along this normal planes have to be centered 
&nbsp;
&nbsp; OUTPUT
&nbsp; CPos, Cell array with in each cell indeces to a group of points in the same plane
</pre><a name="ref14"></a><br><big><big>triSurfaceLaplacian</big></big><br><br><pre>  FUNCTION L = triSurfaceLaplacian(surface)
&nbsp;
&nbsp; DESCRIPTION
&nbsp; This function computes the surface laplacian matrix for a given 
&nbsp; surface.
&nbsp;
&nbsp; INPUT
&nbsp; surface         Surface to be used in laplacian operation
&nbsp;
&nbsp; OUTPUT
&nbsp; L               Surface laplacian matrix
&nbsp;
&nbsp; SEE ALSO
</pre><a name="ref15"></a><br><big><big>triTriangulate</big></big><br><br><pre>  function Tri = triTriangulate(Pos,Slices)
&nbsp;
&nbsp; This is a simple triangulation algorithm
&nbsp; It takes to sequential rings of the model and
&nbsp; adds a surface in between. 
&nbsp;
&nbsp; INPUT
&nbsp;   Pos -  A matrix containing all node positions
&nbsp;   Slices -  A cell array. Every cell contains a vector of indices to the nummer of nodes
&nbsp;             contained in one ring. For the algorithm to work properly, one needs to supply the 
&nbsp;             the rings in an order they can be triangulated
&nbsp;
&nbsp;
&nbsp; OUTPUT
&nbsp;   Tri  - Matrix containing the triangulated data
</pre><a name="ref16"></a><br><big><big>triVector3</big></big><br><br><pre>  function Pos3 = triVector3(Pos4)
&nbsp;
&nbsp; Strip the fourth redundant coordinate
&nbsp; and go back to the cartesian coordinate system
&nbsp;
&nbsp; INPUT
&nbsp; Pos4 - matrix with four vectors
&nbsp;
&nbsp; OUTPUT
&nbsp; Pos3 - matrix with three vectors
</pre><a name="ref17"></a><br><big><big>triVector4</big></big><br><br><pre>  function Pos4 = triVector4(Pos3)
&nbsp;
&nbsp; This function transforms a normal matrix containing the position in three
&nbsp; coordinates into a opengl-style four vector matrix.
&nbsp; The difference is that the last position is used as a scaling number
&nbsp; The latter makes a translation a matrix multiplication as well
&nbsp; Hence all transformations on 4-vector can be described as matrix multiplications
&nbsp;
&nbsp; INPUT 
&nbsp; Pos3 - matrix with a three cartesian coordinates per column
&nbsp;
&nbsp; OUTPUT 
&nbsp; Pos4 - matrix with four cartesian coordinates per column
</pre> <br>
<br>
<br>
<a href="index.html"><big>[documentation home]</big></a><br>
<script type="text/javascript">postContent();</script>
</body>
</html>

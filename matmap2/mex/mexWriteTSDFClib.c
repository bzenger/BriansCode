/* FILE: mexReadTSDFC.c  
   AUTHOR: Jeroen Stinstra
   CONTENTS: Wrting fiducials to a tsdfc file 
   
   LASTUPDATE: 7 JUN 2002.
 *
 */
 
 /* 
   This function writes fiducials in a TSDFC file. 
 */
 
/* Do the standard includes */

#include <stdio.h>
#include <math.h>
#include <mex.h>
#include "gdbm.h"

/* include a bunch of functions */

#include "mexio.h"
#include "mexio.c"  /* need to put this in a library file or something, have to find out how this works on the SGIs */ 

/* just define them */
#define FALSE	0
#define TRUE	1

typedef struct 		  { double 	*fids;
                            long	size;
			    long 	type;
			    long 	fidset;    
                            long	fidsetnum;     /* new fidset number */
                        } my_fids;

typedef struct            { char 	*label;
			    char 	*audit;
		          } my_fidset;	

typedef struct               {  short   type;
                                short	version;
                                int	size;
                                char	*audit;
                                int	auditsize;
                                char	*label;
                                int	labelsize;
                                int	fidsdescarraysize; 
                                short	*fidsdescarray;
                                int	fidsvaluesarraysize;
                                float	*fidsvaluesarray;
                                short	*fidstypesarray;
                              } fidset;
                              

/* Function definitions */
my_fids		*GetFidsArray(mxArray *fidsarray);
my_fidset 	*GetFidsetArray(mxArray *fidsetarray);
datum 		EncodeFidset(mxArray *fidsarray, mxArray *fidsetarray);
void 		WriteFidset(char *tsdfcfilename,char *tsdffilename, datum data);

/* globals */

char 	matlablabelglobal[]  = "Matlab generated global fiducials";
char 	matlablabellocal[]  = "Matlab generated local fiducials";
char	matlabaudit[]  = "Fiducials generated by ioWriteTSDFC()";
                            
                            
void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
/* Entry point for MATLAB. 
    lefthandside                        righthandside
    [outmat1,outmat2,...] = function(inmat1,inmat2,...)
    nlhs - number of parameters on leftside hand of expression
    plhs - a pointer to an array of pointers representing the various arrays on this side
    nrhs - idem right hand side
    prhs - idem array pointer right hand side
*/
{
    char		*tsdffilename, *tsdfcfilename;
    mxArray		*fidsarray, *fidsetarray;
    datum		datum;
       
    /*  Set usage string 
	The function input is: 
	    - TSDFC char matrix containing the filename
	    - TSDF char matrix containing the key 
	The output are two sets of arrays
	    - a fids array this one contains a fid entry and contains parts of the 
	      fidsets broken down in parts so in each entry there is one type of
	      fiducial and which can be a vector or scalar depending on the local or global 
	      status of the fiducial.
	    - fidset cell array, representing all fidsets in the timeseries, it contains all
	      the data like the auditstring, the label, but not the data as it is broken down
	      in smaller pieces in fids. fids does contain a pointer to fidset in the form of
	      an index.       
     */
    mexioError(NULL,NULL,"mexReadTSDFC(TSDFC-filename,TSDF-filename/key,fids,fidset)"); /* no error, just setting usage once and for all */
    /* INPUT */
    
    if (nrhs != 4)
	mexioError("mexFunction","The name of the TSDFC-file and the TSDF-file are needed and the fiducials and the fidsets",NULL);
	
    if (!mxIsChar(prhs[0]))
        mexioError("mexFunction","TSDFC-filename needs to be a string",NULL);

    if (!mxIsChar(prhs[1]))
        mexioError("mexFunction","TSDF-filename needs to be a string",NULL);

    if (!mxIsStruct(prhs[2]))
        mexioError("mexFunction","fids needs to be a structured array",NULL);

    if (!mxIsCell(prhs[3]))
        mexioError("mexFunction","fidset needs to be a cell array",NULL);
    

    /* OUTPUT */

    if (nlhs > 0)
	mexioError("mexFunction","No output is generated by this function",NULL);
	
    /* Retrieve the filenames */
    
    tsdfcfilename = mexioConvertString((mxArray *)prhs[0]);
    tsdffilename = mexioConvertString((mxArray *)prhs[1]);

    fidsarray = (mxArray *)prhs[2];
    fidsetarray = (mxArray *)prhs[3];
    
    /* So the filenames are read */	
  
    datum = EncodeFidset(fidsarray,fidsetarray);
    WriteFidset(tsdfcfilename,tsdffilename,datum);
 
}
    

my_fids	*GetFidsArray(mxArray *fidsarray)
/* This function translates the matlab array in a normal array 
   and stores the fiducials in a large array */
{
    int		typeindex,valueindex,fidsetindex;
    long	p; /* loop counters */
    long	numfidsarray;   /* how long is fids array */
    my_fids	*myfids;
    mxArray	*array;		/* to store a subarray in */
    double	*data;		/* to store the contents of a matrix */
    
    
    if(!(mxIsStruct(fidsarray)))
        mexioError("GetFidsArray","fidsarray is not a struct",NULL);

    numfidsarray = (long)(mxGetN(fidsarray)*mxGetM(fidsarray));
    
    if (!( myfids = mxCalloc(numfidsarray,sizeof(my_fids))))
        mexioError("GetFidsArray","Cannot allocate memory",NULL);

    /* process fidsarray */
    valueindex = mxGetFieldNumber(fidsarray,"value");
    if( valueindex < 0 ) mexioError("GetFidsArray","The value field is lacking from the fidsarray",NULL);
    typeindex = mxGetFieldNumber(fidsarray,"type");
    if( typeindex < 0 )  mexioError("GetFidsArray","The type field is lacking from the fidsarray",NULL);
    fidsetindex = mxGetFieldNumber(fidsarray,"fidset");
    if( fidsetindex < 0 ) mexioError("GetFidsArray","The fidset field is lacking from the fidsarray",NULL);

    /* Build an array composed with the contents of the fidsarray for easier access */

    for(p=0;p<numfidsarray;p++)
    {
        array = mxGetFieldByNumber(fidsarray,p,valueindex);
        myfids[p].fids = mxGetPr(array);
        myfids[p].size = (long)(mxGetN(array)*mxGetM(array));
        
        array = mxGetFieldByNumber(fidsarray,p,typeindex);
        if(!( data = mxGetPr(array)))
            mexioError("GetFidsArray","Could not access type in fids array",NULL);
        myfids[p].type = (long) data[0];
        
        array = mxGetFieldByNumber(fidsarray,p,fidsetindex);
        if(!( data = mxGetPr(array)))
            mexioError("GetFidsArray","Could not access fidset in fids array",NULL);
        myfids[p].fidset = (long) data[0];
        myfids[p].fidsetnum = 0;
        
    }
    
    return(myfids);
}


my_fidset	*GetFidsetArray(mxArray *fidsetarray)
/* This function translates the matlab array in a normal array 
   and stores the fidset data in a large array */
{
    mxArray	*label,*audit,*structarray;
    long	p; /* loop counters */
    long	numfidsetarray; /* kow long is fids array */
    my_fidset	*myfidset;
    
    
    if(!(mxIsCell(fidsetarray)))
        mexioError("GetFidsetArray","fidsetarray is not a cellarray",NULL);

    numfidsetarray = (long)(mxGetN(fidsetarray)*mxGetM(fidsetarray));
    
    if (!( myfidset = mxCalloc(numfidsetarray,sizeof(my_fidset))))  /* Create an empty array */
        mexioError("GetFidsetArray","Cannot allocate memory",NULL);

    /* Build an array composed with the contents of the fidsarray for easier access */

    for(p=0;p<numfidsetarray;p++)
    {
        myfidset[p].label = NULL;
        myfidset[p].audit = NULL;
    
        if (!( structarray = mxGetCell(fidsetarray,p))) continue;		/* go to next cell */
        if( label = mxGetField(structarray,0,"label"))
            myfidset[p].label = mexioConvertString(label);
        if( audit = mxGetField(structarray,0,"audit"))
            myfidset[p].audit = mexioConvertString(audit);
            
    }
    
    return(myfidset);
}


datum EncodeFidset(mxArray *fidsarray, mxArray *fidsetarray)
/* Encode the data again to fit in the tsdfc files again */
{
    long 	numfidsetarray,numfidsarray;
    my_fids	*myfids;
    my_fidset	*myfidset;
    fidset	*newfidset;
    long	p,q,r,s,size,numfidset,fidsetsize,fidsetnumber;
    int		blocksize,datasize,headersize;
    datum	data;
    char	*cdata;
 
    numfidsarray = (long)(mxGetN(fidsarray)*mxGetM(fidsarray));
    numfidsetarray = (long)(mxGetN(fidsetarray)*mxGetM(fidsetarray));

    myfids = GetFidsArray(fidsarray);
    myfidset = GetFidsetArray(fidsetarray);

    numfidset = 0;
    
    /* The basic idea is to sort out which fiducials can be combined into
       one fiducial set, the criterium is : size should be equal and fidset.
       If so mark them in fidsetnum and give all the same number. This number
       will be used lateron to decide which fiducials are put in the same fidset */
    
    for (p=0;p<numfidsarray;p++)
    {
        if (myfids[p].fidsetnum == 0)
        {
             myfids[p].fidsetnum = ++numfidset;  /* we found a new fidset */
             fidsetnumber = myfids[p].fidset;
             size = myfids[p].size;
                  
             for (q=p+1;q<numfidsarray;q++)
             {
                  if ((myfids[q].size == size)&&(myfids[q].fidset == fidsetnumber)) 
                  {
                      myfids[q].fidsetnum = numfidset;
                  }
             }
        }
    }

    
    if(!( newfidset = mxCalloc(numfidset,sizeof(fidset))))
        mexioError("EncodeFidset","Could not alloate memory for new set",NULL);
    
   
    blocksize = 0;    
                
    for (p=0;p<numfidset;p++)
    {
        fidsetsize = 0;
        size = 0;
        fidsetnumber = 0;
        datasize = 0;
        headersize = sizeof(short)+sizeof(short)+sizeof(int);	/* tsdfc-subheader */
        
        newfidset[p].type = 1;
        newfidset[p].version = 0;
        newfidset[p].label = NULL;
        newfidset[p].audit = NULL;
           
        /* determine the size of this fidset, the number of fiucials and the length of the fiducials */
        for (q=0;q<numfidsarray;q++) 
            if (myfids[q].fidsetnum == p+1) { fidsetsize++; size = myfids[q].size; fidsetnumber = myfids[q].fidset;}
            
        if ((fidsetnumber > 0)&&(fidsetnumber < numfidsetarray+1))
            {
                newfidset[p].label = myfidset[fidsetnumber-1].label;
                newfidset[p].audit = myfidset[fidsetnumber-1].audit;
            }

        if (newfidset[p].label == NULL) 
        {
            if (size > 1) { newfidset[p].label = matlablabellocal; }
            else { newfidset[p].label = matlablabelglobal; }
        }
        if (newfidset[p].audit == NULL) newfidset[p].audit = matlabaudit;

        newfidset[p].labelsize = strlen(newfidset[p].label);
        newfidset[p].auditsize = strlen(newfidset[p].audit);
        datasize += sizeof(int) + newfidset[p].labelsize;
        datasize += sizeof(int) + newfidset[p].auditsize;

        newfidset[p].fidsdescarraysize = (int) size;           
        if (!( newfidset[p].fidsdescarray = mxCalloc(size,sizeof(short))))
                mexioError("EncodeFids","Could not allocate memory (descarray)",NULL);
        for (q=0;q<size;q++) newfidset[p].fidsdescarray[q] = (short) fidsetsize;        
        
        datasize += sizeof(int) + size*sizeof(short);
        
        newfidset[p].fidsvaluesarraysize = (long) size*fidsetsize;
        if (!( newfidset[p].fidsvaluesarray = mxCalloc(size*fidsetsize,sizeof(float))))
                mexioError("EncodeFids","Could not allocate memory (valuesarray)",NULL);
        if (!( newfidset[p].fidstypesarray = mxCalloc(size*fidsetsize,sizeof(short))))
                mexioError("EncodeFids","Could not allocate memory (typesarray)",NULL);
        
        datasize += sizeof(int) + sizeof(float)*(size*fidsetsize) + sizeof(short)*(size*fidsetsize);
        
        newfidset[p].size = datasize;
        
        r = 0; /* counter on the fiducials */
        /* fill out the last two matrices */
        for (q=0;q<numfidsarray;q++) 
        {
            if (myfids[q].fidsetnum == p+1)
            {
                for (s=0;s<size;s++) 
                { 
                    newfidset[p].fidstypesarray[s*fidsetsize+r] = myfids[q].type;
                    newfidset[p].fidsvaluesarray[s*fidsetsize+r] = (float) myfids[q].fids[s];    
                }
                r++;
            }
        }
        blocksize += headersize+datasize;
    }    
        
    mxFree(myfids);
    mxFree(myfidset);
    
    /***************************************************
        Next step is to pu everything in a datum array
     ******************************************************/
    
    /* allocate memory block */
    data.dptr = (char *) mxCalloc(blocksize,sizeof(char));
    data.dsize = blocksize;
    
    cdata = data.dptr;
    /* fill out structure */

    for (p=0;p<numfidset;p++)
    { 
        memcpy(cdata,&(newfidset[p].type),sizeof(short)); cdata += sizeof(short);
        memcpy(cdata,&(newfidset[p].version),sizeof(short)); cdata += sizeof(short);
        memcpy(cdata,&(newfidset[p].size),sizeof(int)); cdata += sizeof(int);
        
        memcpy(cdata,&(newfidset[p].labelsize),sizeof(int)); cdata += sizeof(int);
        memcpy(cdata,newfidset[p].label,newfidset[p].labelsize); cdata += newfidset[p].labelsize;
        
        memcpy(cdata,&(newfidset[p].auditsize),sizeof(int)); cdata += sizeof(int);
        memcpy(cdata,newfidset[p].audit,newfidset[p].auditsize); cdata += newfidset[p].auditsize;
        
        memcpy(cdata,&(newfidset[p].fidsdescarraysize),sizeof(int)); cdata += sizeof(int);
        memcpy(cdata,newfidset[p].fidsdescarray,sizeof(short)*(newfidset[p].fidsdescarraysize)); cdata += sizeof(short)*(newfidset[p].fidsdescarraysize);
        
        memcpy(cdata,&(newfidset[p].fidsvaluesarraysize),sizeof(int)); cdata += sizeof(int);
        memcpy(cdata,newfidset[p].fidsvaluesarray,sizeof(float)*(newfidset[p].fidsvaluesarraysize)); cdata += sizeof(float)*(newfidset[p].fidsvaluesarraysize);
        memcpy(cdata,newfidset[p].fidstypesarray,sizeof(short)*(newfidset[p].fidsvaluesarraysize)); cdata += sizeof(short)*(newfidset[p].fidsvaluesarraysize);
        
        mxFree(newfidset[p].fidsdescarray); newfidset[p].fidsdescarray = NULL;
        mxFree(newfidset[p].fidsvaluesarray); newfidset[p].fidsvaluesarray = NULL;
        mxFree(newfidset[p].fidstypesarray); newfidset[p].fidstypesarray = NULL;
    }
    return(data);
}


void WriteFidset(char *tsdfcfilename,char *tsdffilename, datum data)
/* This function generates new fidset fot the tsdfc file */
{
    GDBM_FILE 	file;
    datum	key;

    if (!(file = gdbm_open(tsdfcfilename,1024,GDBM_WRCREAT,00644,NULL)))
        mexioError("WriteFidset","Could not open file",NULL);

    key.dptr = (char *)tsdffilename;
    key.dsize = strlen(tsdffilename);

    if ( gdbm_store(file,key,data,GDBM_REPLACE))
        {gdbm_close(file); mexioError("WriteFidset","Could not store the fiducials in the TSDFC-file",NULL);}

    gdbm_reorganize(file);
    gdbm_close(file);    

}

